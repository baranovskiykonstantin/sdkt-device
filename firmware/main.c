/*------------------------------------------------------------------------------
 * За основу firmware взята программная реализация низкоскоростного USB
 * для микроконтроллеров AVR V-USB (AKA AVR-USB) пример custom class
 * За деталями реализации всего проекта сюда - http://www.obdev.at/avrusb/
 *----------------------------------------------------------------------------*/

// Подключение необходимых библиотек
#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>     /* для _delay_ms() */

// Подключение библиотек, необходимых USB драйверу
#include <avr/pgmspace.h>   /* требуется для usbdrv.h */
#include "usbdrv.h"

// Коды запросов (bRequest)
#define RQ_VAR_READ       0x11
#define RQ_VAR_WRITE      0x12

// Коды переменных (wIndex) к которым выполняется обращение
#define CMD               0x01
#define ADDR              0x02
#define FRQ               0x03

// Коды команд cmd
#define CMD_RESET         0x01
#define CMD_SET_ADDR      0x02
#define CMD_COUNT_FRQ     0x03
#define CMD_LEVEL_0       0x04
#define CMD_LEVEL_1       0x05
#define CMD_LEVEL_2       0x06

// Обозначения портов и линий ввода/вывода
#define OUTPUT            PORTA
#define LED               PA3
#define STEP0             PA0
#define STEP1             PA1

// Значения задержек, мс
#define DELAY_RES         2
#define DELAY_DATA        0.9
#define DELAY_CLOCK       0.1
#define DELAY_PAUSE       1

// Логика
#define false             0
#define true              1

// Буфер для обмена данными через USB
unsigned int  dataBuffer[1];

// Переменные, с которыми организован обмен данными через USB
unsigned int  cmd =  0x0000;  // Содержит код команды
unsigned int  addr = 0x0000;  // Содержит адресс измеряемого датчика
volatile unsigned int  frq =  0x0000;   // Содержит значение измеряной частоты

// Переменные для работы в прерываниях
volatile unsigned char int_cntr = 0;    // Вспомогательный счетчик
volatile unsigned char measure = false; // Флаг процесса измерения частоты

//==============================================================================
// Интерфейс USB
//==============================================================================
usbMsgLen_t usbFunctionSetup(uchar data[8])
{
  usbRequest_t *rq = (void *)data;
  unsigned int var = rq->wIndex.word;  // Код переменной
  unsigned int val = rq->wValue.word;  // Значение переменной

  switch(rq->bRequest)
  { 
    //----------------------------------------------------------
    // Работа с переменными
    //----------------------------------------------------------
    case RQ_VAR_READ:        // Чтение значение переменной
      switch(var)
      {
        case CMD:  dataBuffer[0] = cmd;  break;
        case ADDR: dataBuffer[0] = addr; break;
        case FRQ:  dataBuffer[0] = frq;  break;
      }
      usbMsgPtr = dataBuffer; // Преднамеренно передается указатель другого типа
      return 2; // Возвращается размер блока данных в байтах
    //----------------------------------------------------------
    case RQ_VAR_WRITE:       // Запись значения переменной
      switch(var)
      {
        case CMD:  cmd = val;  break;
        case ADDR: addr = val; break;
        case FRQ:  frq = val;  break;
      }
      return 0;
  }
  return 0;   /* default для не реализованных запросов:
                 на хост обратно данные не возвращаются */
}

//==============================================================================
// Функции для работы с платами местных блоков (МБ) СДКТ
//==============================================================================
void set_level_0(void)      // Установить на выходе уровень 0 В
{
  OUTPUT |= (1 << STEP0) | (1 << STEP1);
  return;
}

//------------------------------------------------------------------------------
void set_level_1(void)      // Установить на выходе уровень 6 В
{
  OUTPUT &= ~(1 << STEP0);
  OUTPUT |= 1 << STEP1;
  return;
}

//------------------------------------------------------------------------------
void set_level_2(void)      // Установить на выходе уровень 12 В
{
  OUTPUT &= ~((1 << STEP0) | (1 << STEP1));
  return;
}

//------------------------------------------------------------------------------
void reset(void)            // Сбросить регистры МБ
{
  set_level_0();            // Устанавливаем на выходе LIN уровень "0"
  _delay_ms(DELAY_PAUSE);   // на DELAY_PAUSE мс
  set_level_2();            // Установить высокий уровень на линии LIN
  _delay_ms(DELAY_RES);     // на DELAY_RES мс
  set_level_0();            // Устанавливаем на выходе LIN уровень "0"
  OUTPUT &= ~(1 << LED);    // Выключить светодиод
  return;
}

//------------------------------------------------------------------------------
void send_1(void)           // Записать в регистры МБ логическую единицу
{
  set_level_0();            // Устанавливаем на выходе LIN уровень "0"
  _delay_ms(DELAY_PAUSE);   // на DELAY_PAUSE мс
  set_level_1();            // Установить низкий уровень на линии LIN
  _delay_ms(DELAY_DATA);    // на DELAY_DATA мс
  set_level_2();            // Установить высокий уровень на линии LIN
  _delay_ms(DELAY_CLOCK);   // на DELAY_CLOCK мс
  return;
}

//------------------------------------------------------------------------------
void send_0(void)           // Записать в регистры МБ логический ноль
{
  set_level_0();            // Устанавливаем на выходе LIN уровень "0"
  _delay_ms(DELAY_PAUSE);   // на DELAY_PAUSE мс
  set_level_2();            // Установить высокий уровень на линии LIN
  _delay_ms(DELAY_CLOCK);   // на DELAY_CLOCK мс
  return;
}

//------------------------------------------------------------------------------
void set_adr(void)          // Записать адресс датчика в регистры МБ
{
  unsigned char a;          // Адресс имеет 16 разрядов

  for(a = 0x0F ; a < 0xFF; --a)
  {                         // Первым передается старший разряд
    if(addr & (1 << a))     // Если текущий рзряд не равен "0"
      send_1();             // пердать лог. 1
    else                    // иначе
      send_0();             // передать лог. 0
  }
  _delay_ms(DELAY_RES);     // Задержка для сброса плат в которых не 
                            // совпал адрес
  return;
}

//------------------------------------------------------------------------------
void count_frq(void)        // Измерить частоту входного сигнала
{
  usbPoll();                // Нужно вызывать не реже чем раз в 50 мс
  _delay_ms(10);

  GIMSK &= ~(1 << INT0);    // Запретить внешнее прерывание по INT0
                            // на время измерения
  frq = 0x0000;             // Удалить результат предыдущего измерения
  int_cntr = 0;             // Обнулить счетчик
  // Внешнее прерывание по PCINT0
  GIFR |= (1 << PCIF0);     // Сбросить флаг внешнего прерыв. по PCINT0
  GIMSK |= (1 << PCIE0);    // Разрешить внешнее прерывание по PCINT0
  // Таймер 1
  TCNT1 = 0x0000;           // Обнулить счетный регистр таймера 1
  TIFR1 |= (1 << TOV1);     // Сбросить флаг прерыв. по переполн. Т1
  TIMSK1 |= (1 << TOIE1);   // Разр. прерыв. по переполнению таймера 1

  while(frq == 0x0000);     // Ждать пока завершится измерение

  GIMSK |= (1 << INT0);     // Разрешить внешнее прерывание по INT0
                            // после завершения измерения
}

//==============================================================================
// Обработчики прерываний
//==============================================================================
// С помощью прерываний выполняется измерение одного полного периода входящего
// сигнала:
//                          ___1       2_______3
// начиная со спада ->         |_______|       |___
// или                          _______         ___
// начиная с фронта ->      ___|       |_______|
//
// в зависимости от того, что будет обнаружено первым.
// Первое срабатывание таймера - начало периода, третье срабатывание - конец.
//------------------------------------------------------------------------------
ISR(PCINT0_vect)            // Внешнее прерывание по изменению входного сигнала
{
  int_cntr++;               // Следующий фронт/спад
  // Если обнаружен первый импульс - начать измерение
  if(measure == false)
  {
    TCNT1 = 0x0000;         // Обнулить счетный регистр таймера 1
    TIFR1 |= (1 << TOV1);   // Сбросить флаг прерыв. по переполн. Т1
    TIMSK1 |= (1 << TOIE1); // Разр. прерыв. по переполнению таймера 1
    measure = true;
  }
  // Если обнаружен третий импульс - завершить измерение
  else if(int_cntr == 3)
  {
    TIMSK1 &= ~(1 << TOIE1);// Запр. прерыв. по переполнению таймера 1
    GIMSK &= ~(1 << PCIE0); // Запрешить внешнее прерывание по PCINT0
    measure = false;
    frq = TCNT1;            // Сохранить результат измерения
  }
}

//------------------------------------------------------------------------------
ISR(TIM1_OVF_vect)          // Прерывание по переполнению таймера 1
{
  TIMSK1 &= ~(1 << TOIE1);  // Запр. прерыв. по переполнению таймера 1
  GIMSK &= ~(1 << PCIE0);   // Запрешить внешнее прерывание по PCINT0
  measure = false;
  frq = 0xFFFF;             // Результат 0xFFFF - измеряемая чатота
                            // меньше допустимой или равна нулю
}

//******************************************************************************
// Основная программа
//******************************************************************************
int main(void)
{
  //----------------------------------------------------------------------------
  // Прерывания
  //----------------------------------------------------------------------------
  PCMSK0 |= (1 << PCINT2);  // Входной сигнал подключен к PA2
  TCCR1B |= (1 << CS10);    // Таймер1 без предв. делителя

  //----------------------------------------------------------------------------
  // Интерфейс USB
  //----------------------------------------------------------------------------
  usbInit();                // Инициализация драйвера USB
  usbDeviceDisconnect();    // см. usbdrv.h - запускает реэнумерацию
  _delay_ms(255);           // Подделывам USB disconnect на время > 250 ms
  usbDeviceConnect();       // см. usbdrv.h

  //----------------------------------------------------------------------------
  // Порты ввода/вывода
  //----------------------------------------------------------------------------
  DDRA |= ((1 << LED) | (1 << STEP0) | (1 << STEP1));
  OUTPUT &= ~(1 << LED);    // Выключаем светодиод
  set_level_0();            // Устанавливаем на выходе LIN уровень "0"

  //----------------------------------------------------------------------------
  sei();                    // Разрешить все прерывания

  for(;;)                   // Бесконечный цикл
  {
    if(cmd)                 // Если принята новая команда (не равна нулю)
    {
      switch(cmd)           // Выполняем нужную команду
      {
        case CMD_RESET:     reset();     break;   // Сброс
        case CMD_SET_ADDR:  reset();
                            OUTPUT |= (1 << LED); // Включить светодиод
                            set_adr();   break;   // Установить адресс
        case CMD_COUNT_FRQ: OUTPUT |= (1 << LED); // Включить светодиод
                            count_frq(); break;   // Измерить частоту
        case CMD_LEVEL_0:   reset();
                            OUTPUT |= (1 << LED); // Включить светодиод
                            set_level_0(); break; // Уст. на выходе 0 В
        case CMD_LEVEL_1:   reset();
                            OUTPUT |= (1 << LED); // Включить светодиод
                            set_level_1(); break; // Уст. на выходе 6 В
        case CMD_LEVEL_2:   reset();
                            OUTPUT |= (1 << LED); // Включить светодиод
                            set_level_2(); break; // Уст. на выходе 12 В
      }
      cmd = 0;              // После выполнения команду удалить
    }
    usbPoll();              // Нужно вызывать не реже чем раз в 50 мс
  }
  return 0;
}
//******************************************************************************
